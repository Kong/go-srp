package srp

import (
	"bytes"
	"encoding"
	"encoding/gob"
	"errors"
	"fmt"
	"math/big"
)

type SRPServer struct {
	Params   *SRPParams
	Verifier *big.Int
	Secret2  *big.Int
	B        *big.Int
	M1       []byte
	M2       []byte
	K        []byte
	u        *big.Int
	s        *big.Int
}

// NewServer creates new SRP server
func NewServer(params *SRPParams, Vb []byte, S2b []byte) *SRPServer {

	multiplier := getMultiplier(params)
	V := intFromBytes(Vb)
	secret2 := intFromBytes(S2b)

	Bb := getB(params, multiplier, V, secret2)
	B := intFromBytes(Bb)

	return &SRPServer{
		Params:   params,
		Secret2:  secret2,
		Verifier: V,
		B:        B,
		M1:       nil,
		M2:       nil,
		K:        nil,
		u:        big.NewInt(0),
		s:        big.NewInt(0),
	}
}

// ComputeB server creates B
func (s *SRPServer) ComputeB() []byte {
	return intToBytes(s.B)
}

// SetA set 'A' generated by client
func (s *SRPServer) SetA(A []byte) error {
	AInt := intFromBytes(A)
	U := getu(s.Params, AInt, s.B)
	S, err := serverGetS(s.Params, s.Verifier, AInt, s.Secret2, U)
	if err != nil {
		return err
	}

	s.K = getK(s.Params, S)
	s.M1 = getM1(s.Params, A, intToBytes(s.B), S)
	s.M2 = getM2(s.Params, A, s.M1, s.K)

	s.u = U               // only for tests
	s.s = intFromBytes(S) // only for tests
	return nil
}

// CheckM1 check client proof
func (s *SRPServer) CheckM1(M1 []byte) ([]byte, error) {
	if !bytes.Equal(s.M1, M1) {
		return nil, errors.New("Client did not use the same password")
	} else {
		return s.M2, nil
	}
}

// ComputeK compute session key
func (s *SRPServer) ComputeK() []byte {
	return s.K
}

// Helpers

func serverGetS(params *SRPParams, V, A, S2, U *big.Int) ([]byte, error) {
	ALessThan0 := A.Cmp(big.NewInt(0)) <= 0
	NLessThanA := params.N.Cmp(A) <= 0
	if ALessThan0 || NLessThanA {
		return nil, errors.New("invalid client-supplied 'A', must be 1..N-1")
	}

	result1 := new(big.Int)
	result1.Exp(V, U, params.N)

	result2 := new(big.Int)
	result2.Mul(A, result1)

	result3 := new(big.Int)
	result3.Exp(result2, S2, params.N)

	result4 := new(big.Int)
	result4.Mod(result3, params.N)

	return padToN(result4, params), nil
}

func getB(params *SRPParams, multiplier, V, b *big.Int) []byte {
	gModPowB := new(big.Int)
	gModPowB.Exp(params.G, b, params.N)

	kMulV := new(big.Int)
	kMulV.Mul(multiplier, V)

	leftSide := new(big.Int)
	leftSide.Add(kMulV, gModPowB)

	final := new(big.Int)
	final.Mod(leftSide, params.N)

	return padToN(final, params)
}

//nolint:exhaustruct
var (
	_ encoding.BinaryMarshaler   = &SRPServer{}
	_ encoding.BinaryUnmarshaler = &SRPServer{}
)

// MarshalBinary returns a binary gob with the complete state of the SRP object.
// It can be used in conjunction with UnmarshalBinary() to use this module in a
// context in which mutating state of objects is inappropriate.
func (s *SRPServer) MarshalBinary() ([]byte, error) {
	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	// This array must be in the exact same order as the array used for unmarshalling.
	values := []interface{}{
		s.Params,
		s.Verifier,
		s.Secret2,
		s.B,
		s.M1,
		s.M2,
		s.K,
		s.u,
		s.s,
	}

	for _, value := range values {
		if err := enc.Encode(value); err != nil {
			return nil, fmt.Errorf("encoding failure: %w", err)
		}
	}

	return buf.Bytes(), nil
}

// UnmarshalBinary unmarshal binary gob created with MarshalBinary.
func (s *SRPServer) UnmarshalBinary(data []byte) error {
	dec := gob.NewDecoder(bytes.NewBuffer(data))
	// This array must be in the exact same order as the array used for marshaling.
	values := []interface{}{
		&s.Params,
		&s.Verifier,
		&s.Secret2,
		&s.B,
		&s.M1,
		&s.M2,
		&s.K,
		&s.u,
		&s.s,
	}
	for _, value := range values {
		if err := dec.Decode(value); err != nil {
			return fmt.Errorf("decoding failure: %w", err)
		}
	}

	return nil
}
